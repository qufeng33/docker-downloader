# 技术架构规范

## NestJS 模块化设计规范

### 模块组织原则

- 按业务功能划分模块，每个模块负责单一职责
- 核心业务模块：Registry（仓库管理）、Download（下载管理）、Auth（认证）、Config（配置）、Packaging（打包）
- 模块间通过依赖注入进行解耦，避免循环依赖
- 共享功能抽取为独立的服务模块

### 目录结构要求

- 主进程模块应按功能分组，每个模块包含独立的目录
- 每个模块目录应包含模块定义、服务类、控制器和数据传输对象
- 模块内部文件命名应遵循 NestJS 约定
- 共享类型和工具函数应放在独立的共享目录中

### 服务层设计要求

- 每个模块必须包含 Service、Controller 和相关的 DTO
- Service 层专注业务逻辑，Controller 层专注 IPC 通信
- 数据持久化必须使用 Repository 模式
- 复杂业务逻辑应拆分为多个专门的服务类

## IPC 通信最佳实践

### @doubleshot/nest-electron 使用规范

- 请求-响应模式必须使用 IpcHandle 装饰器
- 事件监听模式必须使用 IpcOn 装饰器
- IPC 方法命名必须采用 kebab-case 格式
- 控制器方法名必须使用 camelCase 格式

### IPC 通信规范要求

- 所有 IPC 控制器必须使用 Controller 装饰器并指定命名空间
- IPC 方法必须正确处理异步操作和错误传播
- 事件处理方法应通过事件发射器传递到应用内部
- 控制器应保持轻量，复杂逻辑委托给服务层

### 类型安全要求

- 所有 IPC 方法必须定义明确的输入输出类型
- 必须使用 DTO 类进行参数验证和类型约束
- 渲染进程调用必须使用自动生成的类型定义
- 避免使用 any 类型，确保类型安全

## 依赖注入使用规范

### 服务注册要求

- 所有服务类必须使用 Injectable 装饰器
- 服务必须在对应模块的 providers 数组中注册
- 构造函数应避免执行复杂逻辑
- 初始化逻辑应使用 onModuleInit 生命周期钩子

### 依赖注入最佳实践

- 优先使用构造函数注入方式
- 严格避免循环依赖，必要时使用 forwardRef
- 使用接口定义服务契约，便于测试和替换实现
- 服务间的依赖关系应清晰明确

### 配置管理要求

- 应用配置必须使用 @nestjs/config 管理
- 配置项应通过环境变量或配置文件加载
- 敏感配置必须使用安全存储
- 配置验证应在应用启动时进行

## 事件驱动架构指导

### 事件系统设计要求

- 应用内事件必须使用 @nestjs/event-emitter 处理
- 异步事件（下载进度、状态变更）必须通过事件系统传递
- 事件命名必须采用"模块.动作"格式
- 事件负载应使用明确的类型定义

### 事件处理规范

- 事件发射应使用语义化的事件名称
- 事件监听器应正确处理异常情况
- 长时间运行的事件处理应避免阻塞
- 事件处理应保持幂等性

### 异步处理要求

- 长时间运行的任务必须使用异步处理
- 异步操作必须正确使用 Promise 和 async/await
- 错误处理必须完整，避免未捕获的异常
- 异步任务应支持取消和超时机制

## 错误处理架构

### 异常分类和传播

- 必须区分业务异常和系统异常
- IPC 调用中的错误必须正确传播到渲染进程
- 错误信息必须用户友好且不泄露敏感信息
- 必须使用自定义异常类区分不同类型的错误

## 性能优化指导

### 内存管理要求

- 必须及时清理不再使用的资源
- 严格避免内存泄漏，特别是事件监听器
- 大文件处理必须使用流式处理
- 定期监控内存使用情况

### 并发控制要求

- 下载任务必须使用队列管理，控制并发数量
- 网络连接必须使用连接池管理
- 严格避免阻塞主线程的长时间操作
- 并发任务应支持优先级和限流机制
